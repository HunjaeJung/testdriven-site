---
title: Authentication
layout: course
permalink: channels-auth
intro: false
part: 1
lesson: 3
share: true
type: course
course: channels
---

Authentication is the cornerstone of any app that handles user data. It allows users to maintain privacy within the app, while gaining access to the full set of features afforded with registration.

With Django REST Framework (DRF), we have [four](http://www.django-rest-framework.org/api-guide/authentication/#api-reference) authentication classes to choose from:

1. `BasicAuthentication`
1. `TokenAuthentication`
1. `SessionAuthentication`
1. `RemoteUserAuthentication`

We can eliminate `BasicAuthentication` right off the bat because it doesn't offer enough security for production environments. Between the remaining three classes, we should use `TokenAuthentication` because it offers the best support for both desktop and mobile clients. The idea is simple--the server generates a token for a user on login and that token can then be used from any device to gain access to protected APIs.

Start by setting up our app to use Django REST Framework's token-based authentication within *example_taxi/settings.py*:

```python
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework.authentication.TokenAuthentication',
    )
}
```

> During the course of this tutorial, we are going to be following test-driven development (TDD) to confirm that our code works. In the next part of the tutorial, we will be adding a user interface so that we can play with the app as an actual user.

## Sign up

Let's create a new user account via an API. Users should be able to download our app and immediately sign up for a new account by providing the bare minimum of information--username, password, and their names. The distinction between `password1` and `password2` correlates to users entering their passwords and then confirming them. Eventually, our app will present users with a form with input fields and a submit button.

*example/tests.py*:

```python
from django.contrib.auth import get_user_model
from rest_framework.reverse import reverse
from rest_framework.status import HTTP_201_CREATED
from rest_framework.test import APIClient, APITestCase

PASSWORD = 'pAssw0rd!'


class AuthenticationTest(APITestCase):
    def setUp(self):
        self.client = APIClient()

    def test_user_can_sign_up(self):
        response = self.client.post(reverse('sign_up'), data={
            'username': 'user@example.com',
            'first_name': 'Test',
            'last_name': 'User',
            'password1': PASSWORD,
            'password2': PASSWORD
        })
        user = get_user_model().objects.last()
        self.assertEqual(HTTP_201_CREATED, response.status_code)
        self.assertEqual(response.data['id'], user.id)
        self.assertEqual(response.data['username'], user.username)
        self.assertEqual(response.data['first_name'], user.first_name)
        self.assertEqual(response.data['last_name'], user.last_name)
```

A couple things to note:

1. We expect our API to return a 201 status code when the user account is created
2. The response data should be a JSON-serialized representation of our user model

Run the test:

```bash
(env)$ python manage.py test example.tests
```

It should fail:

```bash
django.urls.exceptions.NoReverseMatch: Reverse for 'sign_up' not found.
'sign_up' is not a valid view function or pattern name.
```

Remember: A tenant of TDD is that we should write failing tests (red) before writing the code to get them to pass (green).

We need to create several pieces of code before our tests will pass.

Typically, a data model is the first thing we want to create in a situation like this. We've already created a user model, and since it extends Django's built-in model, it already supports the fields we need.

The next bit of code we need to create is the user serializer in *example/serializers.py*:

```python
from django.contrib.auth import get_user_model
from rest_framework import serializers


class UserSerializer(serializers.ModelSerializer):
    password1 = serializers.CharField(write_only=True)
    password2 = serializers.CharField(write_only=True)

    def validate(self, data):
        if data['password1'] != data['password2']:
            raise serializers.ValidationError('Passwords must match.')
        return data

    def create(self, validated_data):
        data = {
            key: value for key, value in validated_data.items()
            if key not in ('password1', 'password2')
        }
        data['password'] = validated_data['password1']
        return self.Meta.model.objects.create_user(**data)

    class Meta:
        model = get_user_model()
        fields = (
            'id', 'username', 'password1', 'password2',
            'first_name', 'last_name',
        )
        read_only_fields = ('id',)
```

Remember: Right now our user data is basic (first name, last name, username, and password), so we only need access to a few fields. *We should never need to read the password.*

Next, add a new view to *example/apis.py*:

```python
from django.contrib.auth import get_user_model
from rest_framework import generics
from rest_framework.response import Response

from .serializers import UserSerializer


class SignUpView(generics.CreateAPIView):
    queryset = get_user_model().objects.all()
    serializer_class = UserSerializer
```

Here, we created a `SignUpView` that extends Django REST Framework's `CreateAPIView` and leverages our `UserSerializer` to create a new user.

Here's how it works behind the scenes:

1. Django passes request data to the `SignUpView`, which in turn attempts to create a new user with the `UserSerializer`. The serializer checks if the passwords match.
1. If all of the data is valid, then the serializer creates and returns a new user. If it fails, then the serializer returns the errors. Even if the passwords match, validation could fail if the username is already taken or the password isn't strong enough.

Finally, configure a URL to link to our view in *example_taxi/urls.py*:

```python
from django.conf.urls import url
from django.contrib import admin

from example.apis import SignUpView

urlpatterns = [
    url(r'^admin/', admin.site.urls),
    url(r'^api/sign_up/$', SignUpView.as_view(), name='sign_up'),
]
```

Run the tests:

```bash
(env)$ python manage.py test example.tests
```

They should pass!

> Keep in mind that throughout this course we will only be testing the happy paths. Adding tests for error handling is a separate exercise left to the reader.

To manually test, fire up the server and navigate to the [Browsable API](http://www.django-rest-framework.org/topics/browsable-api/) at  [http://localhost:8000/api/sign_up/](http://localhost:8000/api/sign_up/):

![drf sign up page](../../images/01_drf_sign_up.png)

Take note of the following error:

```
HTTP 405 Method Not Allowed
Allow: POST, OPTIONS
Content-Type: application/json
Vary: Accept

{
    "detail": "Method \"GET\" not allowed."
}
```

That's expected since we don't have a GET route set up. You can still test out the POST functionality using the HTML form, though:

```
HTTP 201 Created
Allow: POST, OPTIONS
Content-Type: application/json
Vary: Accept

{
    "id": 1,
    "username": "michael@mherman.org",
    "first_name": "Michael",
    "last_name": "Herman"
}
```

## Log in and out

Now that we can sign up a new user, the next logical step is to create the functionality to log the user in and out.

When a user logs in, the server should create a token for that user. By including that token in the request headers of future requests, the user can access other APIs. The token should be deleted when the user logs out.

Start by adding two new tests to handle the log in and log out behavior to *example/tests.py*:

```python
from django.contrib.auth import get_user_model
from rest_framework.authtoken.models import Token
from rest_framework.reverse import reverse
from rest_framework.status import HTTP_201_CREATED, HTTP_200_OK, \
    HTTP_204_NO_CONTENT
from rest_framework.test import APIClient, APITestCase

from .serializers import PrivateUserSerializer, UserSerializer

PASSWORD = 'pAssw0rd!'


def create_user(username='user@example.com', password=PASSWORD):
    return get_user_model().objects.create_user(
        username=username, password=password)


class AuthenticationTest(APITestCase):

    def setUp(self):
        self.client = APIClient()

    # Function collapsed for clarity.
    def test_user_can_sign_up(self): ...

    def test_user_can_log_in(self):
        user = create_user()
        response = self.client.post(reverse('log_in'), data={
            'username': user.username,
            'password': PASSWORD,
        })
        self.assertEqual(HTTP_200_OK, response.status_code)
        self.assertEqual(PrivateUserSerializer(user).data, response.data)
        self.assertIsNotNone(Token.objects.get(user=user))

    def test_user_can_log_out(self):
        user = create_user()
        token = Token.objects.create(user=user)
        self.client.credentials(HTTP_AUTHORIZATION=f'Token {token}')
        self.client.login(username=user.username, password=PASSWORD)
        response = self.client.post(reverse('log_out'))
        self.assertEqual(HTTP_204_NO_CONTENT, response.status_code)
        self.assertFalse(Token.objects.filter(user=user).exists())
```

> Note that we added a `create_user()` helper function to help keep our code DRY.

The process of logging in is as easy as signing up. The user enters her username and password and submits them to the server. We expect the server to log the user in and then return a success status along with the serialized user data. At this point, we can confirm that a token has been created for the user.

Logging out is even simpler. The user should be logged out when she hits the appropriate API and her token should be deleted.

Run the tests and watch them fail with an `ImportError: cannot import name 'PrivateUserSerializer'` error:

```bash
(env)$ python manage.py test example.tests
```

Add the serializer to *example/serializers.py*:

```python
class PrivateUserSerializer(UserSerializer):
    class Meta(UserSerializer.Meta):
        fields = list(UserSerializer.Meta.fields) + ['auth_token']
```

Now that tokens are being created, we should have two different user serializers--one for public consumption and one for private use. Only logged-in users should be able to receive their tokens. Other users can see each others' basic information, but that's it! If you serve the app over HTTPS, there is little concern about someone stealing tokens from our private response payloads.

The tests should fail again:

```bash
django.urls.exceptions.NoReverseMatch: Reverse for 'log_in' not found.
'log_in' is not a valid view function or pattern name.

...

django.urls.exceptions.NoReverseMatch: Reverse for 'log_out' not found.
'log_out' is not a valid view function or pattern name.
```

*example/apis.py*:

```python
from django.contrib.auth import get_user_model
from django.contrib.auth import login, logout
from django.contrib.auth.forms import UserCreationForm, AuthenticationForm
from rest_framework import permissions, status, views, generics
from rest_framework.authtoken.models import Token
from rest_framework.response import Response

from .serializers import PrivateUserSerializer, UserSerializer


# Class collapsed for clarity.
class SignUpView(views.APIView): ...


class LogInView(views.APIView):
    def post(self, *args, **kwargs):
        form = AuthenticationForm(data=self.request.data)
        if form.is_valid():
            user = form.get_user()
            login(self.request, user)
            Token.objects.get_or_create(user=user)
            return Response(PrivateUserSerializer(user).data)
        else:
            return Response(form.errors, status=status.HTTP_400_BAD_REQUEST)


class LogOutView(views.APIView):
    permission_classes = (permissions.IsAuthenticated,)

    def post(self, *args, **kwargs):
        Token.objects.get(user=self.request.user).delete()
        logout(self.request)
        return Response(status=status.HTTP_204_NO_CONTENT)
```

We programed our log in and log out functions as we planned in the tests. Let's break each view down:

1. In our `LogInView`, we leveraged Django's `AuthenticationForm`, which expects a username and password to be provided. We validated the form to get an existing user and then we logged that user in. Next, we created a token. Note that using `get_or_create()` allows us to avoid having to generate a new token every time a logged-in user hits the "log in" API.
1. Our `LogOutView` does the opposite of the `LogInView`: It logs the user out and deletes her token. We added an `IsAuthenticated` permission to ensure that only logged-in users can log out.


Link our new views to URLs in the existing configuration in *example_taxi/urls.py*:

```python
from django.conf.urls import url
from django.contrib import admin

from example.apis import SignUpView, LogInView, LogOutView

urlpatterns = [
    url(r'^admin/', admin.site.urls),
    url(r'^api/sign_up/$', SignUpView.as_view(), name='sign_up'),
    url(r'^api/log_in/$', LogInView.as_view(), name='log_in'),
    url(r'^api/log_out/$', LogOutView.as_view(), name='log_out'),
]
```

Run the authentication tests one last time to make sure they pass:

```bash
(env)$ python manage.py test example.tests

Creating test database for alias 'default'...
System check identified no issues (0 silenced).
...
----------------------------------------------------------------------
Ran 3 tests in 0.657s

OK
Destroying test database for alias 'default'...
```

## Sanity Check

Our authentication work is done! But, before moving on, ensure you can log in at [http://localhost:8000/api/log_in/](http://localhost:8000/api/log_in/):

![drf log in page](../../images/01_drf_log_in1.png)

![drf log in page](../../images/01_drf_log_in2.png)

You can also test via cURL:

```bash
$ curl -X POST http://localhost:8000/api/sign_up/ \
  -d "username=michael@something.com&password1=test&password2=test&first_name=michael&last_name=herman"
{
  "id":5,
  "username": "michael@something.com",
  "first_name": "michael",
  "last_name": "herman"
}

$ curl -X POST http://localhost:8000/api/log_in/ \
  -d "username=michael@something.com&password=test"
{
  "id":5,
  "username": "michael@something.com",
  "first_name": "michael",
  "last_name": "herman",
  "auth_token": "3f9d0960ab9f492af71d0c2b68e09e3bb78c7345"
}

$ curl -X POST http://localhost:8000/api/log_out/ \
  -H "Authorization: Token 3f9d0960ab9f492af71d0c2b68e09e3bb78c7345"
```
