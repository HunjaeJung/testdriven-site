---
title: WebSockets
layout: course
permalink: channels-web-sockets
intro: false
part: 1
lesson: 5
share: true
type: course
course: channels
---

Up until now, we have dealt with users in a generic way. Users can authenticate and they can retrieve trips. The following section separates users into distinct roles, and this is where things get interesting. Fundamentally, users can participate in trips in one of two ways--they either drive the cars or they ride in them. A rider initiates the trip with a request, which is broadcasted to all available drivers. A driver starts a trip by accepting the request. At this point, the driver heads to the pick-up address. The rider is instantly alerted that a driver has started the trip and other drivers are notified that the trip is no longer up for grabs.

Instantaneous communication between the driver and the rider is vital here, and we can achieve it using [WebSockets](https://en.wikipedia.org/wiki/WebSocket) via [Django Channels](https://channels.readthedocs.io/en/1.x/).

## Django Channels Setup

### Test

Add the following test case to *example/tests.py*:

```python
class WebSocketTripTest(ChannelTestCase):

    def setUp(self):
        self.driver = create_user('driver@example.com')
        self.rider = create_user('rider@example.com')

    def connect_as_driver(self, driver):
        client = HttpClient()
        client.login(username=driver.username, password=PASSWORD)
        client.send_and_consume('websocket.connect', path='/driver/')
        return client

    def connect_as_rider(self, rider):
        client = HttpClient()
        client.login(username=rider.username, password=PASSWORD)
        client.send_and_consume('websocket.connect', path='/rider/')
        return client

    def test_driver_can_connect_via_websockets(self):
        client = self.connect_as_driver(self.driver)
        message = client.receive()
        self.assertIsNone(message)

    def test_rider_can_connect_via_websockets(self):
        client = self.connect_as_rider(self.rider)
        message = client.receive()
        self.assertIsNone(message)
```

Add the import as well:

```python
from channels.test import ChannelTestCase, HttpClient
```

The process of setting up WebSocket tests doesn't differ much from how we configured classic Django tests. In place of `TestCase`, we extended the special `ChannelTestCase` class and we used Channel's `HttpClient` instead of Django's `Client` class.

In order to send and receive messages via WebSockets, we have to open a connection with the server. Our first test ensures that both drivers and riders can connect to their respective endpoints. We implemented the helper functions `connect_as_driver()` and `connect_as_rider()` to facilitate that initial connection step, and we will reuse these functions in future tests.

The tests should fail:

```bash
(env)$ python manage.py test example.tests
```

Error:

```
AssertionError:
Can't find consumer for message <channels.message.Message object at 0x105cb4a58>
```

### Model

Add the following fields to the `Trip` model in *example/models.py*:

```python
driver = models.ForeignKey(
    settings.AUTH_USER_MODEL,
    null=True,
    blank=True,
    on_delete=models.DO_NOTHING,
    related_name='trips_as_driver'
)
rider = models.ForeignKey(
    settings.AUTH_USER_MODEL,
    null=True,
    blank=True,
    on_delete=models.DO_NOTHING,
    related_name='trips_as_rider'
)
```

Add the import:

```python
from django.conf import settings
```

We expanded our existing `Trip` model, in order to link a driver and a rider to a trip. Remember: Drivers and riders are just normal users that belong to different user groups. Later on, we'll see how the same app can serve both types of users and give each a unique experience.

Make and run migrations to update our `Trip` model database table:

```bash
(env)$ python manage.py makemigrations
(env)$ python manage.py migrate
```

### Consumer

Add *example/consumers.py*:

```python
from channels.generic.websockets import JsonWebsocketConsumer


class TripConsumer(JsonWebsocketConsumer):

    def connect(self, message, **kwargs):
        self.message.reply_channel.send({'accept': True})


class DriverConsumer(TripConsumer):
    pass


class RiderConsumer(TripConsumer):
    pass
```

We defined our first consumers to do the bare minimum--accept an incoming WebSockets connection. The `DriverConsumer` and `RiderConsumer` each inherit from a common `TripConsumer` class.

### URLs

We can link the consumer functions to channel routes the same way we link Django views to URLs. To do so, simply update *example_taxi/routing.py* like so:

```python
from channels import route_class

from example.consumers import DriverConsumer, RiderConsumer


channel_routing = [
    route_class(DriverConsumer, path=r'^/driver/$'),
    route_class(RiderConsumer, path=r'^/rider/$'),
]
```

Users can now establish a connection with the server using the `/driver/` and `/rider/` paths:

```bash
(env)$ python manage.py test example.tests
```

## Create Trips

Now that users can connect, we need to enable riders to request trips. Our next test pushes the data necessary to create a trip to the server. On the server side, a new trip should be created and the serialized representation of it should be sent to the subscribed users.

### Test

Add the following test to `WebSocketTripTest` in *example/tests.py*:

```python
def test_rider_can_create_trips(self):
    client = self.connect_as_rider(self.rider)
    client.send_and_consume('websocket.receive', path='/rider/', content={
        'text': {
            'pick_up_address': 'A',
            'drop_off_address': 'B',
            'rider': UserSerializer(self.rider).data
        }
    })
    message = client.receive()
    trip = Trip.objects.last()
    self.assertEqual(TripSerializer(trip).data, message)
```

We start with a failing test.

```bash
(env)$ python manage.py test example.tests
```

Error:

```
AssertionError:
{'pick_up_address': '', 'drop_off_address[48 chars]None} != None
```

### Serializer

We need to modify our `TripSerializer` to handle rider data in *example/serializers.py*:

```python
class ReadOnlyUserSerializer(serializers.ModelSerializer):
    # Without the validator, serialization will fail for users
    # that already exist.
    username = serializers.CharField(validators=[lambda value: value])

    def create(self, validated_data):
        raise NotImplementedError

    def update(self, instance, validated_data):
        raise NotImplementedError

    class Meta:
        model = get_user_model()
        fields = read_only_fields = (
            'id', 'username', 'first_name', 'last_name',
        )


class TripSerializer(serializers.ModelSerializer):
    rider = ReadOnlyUserSerializer(allow_null=True, required=False)

    def create(self, validated_data):
        data = validated_data.pop('rider', None)
        trip = super().create(validated_data)
        if data:
            trip.rider = get_user_model().objects.get(
                username=data['username'])
        trip.save()
        return trip

    class Meta:
        model = Trip
        fields = '__all__'
        read_only_fields = ('id', 'nk', 'created', 'updated',)
```

We also added a special "read only" user model to avoid getting errors when we create our trips. Now, when a rider creates a trip request, her user account should be linked to that trip.

### Consumer

Next, overwrite the `RiderConsumer.receive()` function to process the incoming request data in *example/consumers.py*:

```python
class RiderConsumer(TripConsumer):
    def receive(self, content, **kwargs):
        # Create a new trip record.
        serializer = TripSerializer(data=content)
        serializer.is_valid(raise_exception=True)
        trip = serializer.create(serializer.validated_data)

        # Broadcast the serialized trip data.
        self.send(content=TripSerializer(trip).data)
```

Add the serializer as well:

```python
from .serializers import TripSerializer
```

The client submits a JSON-serialized representation of a trip. Our code deserializes that string into an instance of the `Trip` model and saves it. Then, the consumer re-serializes the newly created trip and broadcasts the data to the connected clients. Eventually, the client can use this data to update the UI.

Running the tests again, we confirm that we can indeed create a new trip via WebSockets.

```bash
(env)$ python manage.py test example.tests
```

## Riders

We abstracted the trip creation out into its own helper function, `create_trip()`. When a rider requests a new trip, a trip object is created with a unique natural key. The server creates a channel group using that unique key and adds the rider's reply channel to it. Now, every time a message is sent to that group the rider will receive it, regardless of who created it.

### Test

To prove this functionality, update `WebSocketTripTest()`:

```python
class WebSocketTripTest(ChannelTestCase):

    def setUp(self):
        self.driver = create_user('driver@example.com')
        self.rider = create_user('rider@example.com')

    def connect_as_driver(self, driver):
        client = HttpClient()
        client.login(username=driver.username, password=PASSWORD)
        client.send_and_consume('websocket.connect', path='/driver/')
        return client

    def connect_as_rider(self, rider):
        client = HttpClient()
        client.login(username=rider.username, password=PASSWORD)
        client.send_and_consume('websocket.connect', path='/rider/')
        return client

    def test_driver_can_connect_via_websockets(self):
        client = self.connect_as_driver(self.driver)
        message = client.receive()
        self.assertIsNone(message)

    def test_rider_can_connect_via_websockets(self):
        client = self.connect_as_rider(self.rider)
        message = client.receive()
        self.assertIsNone(message)

    def create_trip(self, rider, pick_up_address='A', drop_off_address='B'):
        client = self.connect_as_rider(rider)
        client.send_and_consume('websocket.receive', path='/rider/', content={
            'text': {
                'pick_up_address': pick_up_address,
                'drop_off_address': drop_off_address,
                'rider': UserSerializer(rider).data
            }
        })
        return client

    def test_rider_can_create_trips(self):
        client = self.create_trip(self.rider)
        message = client.receive()
        trip = Trip.objects.last()
        self.assertEqual(TripSerializer(trip).data, message)

    def test_rider_is_subscribed_to_trip_channel_on_creation(self):
        client = self.create_trip(self.rider)
        client.receive()
        trip = Trip.objects.last()

        # Subsequent messages sent to the same channel are received
        # by the client.
        message = {'detail': 'This is a test message.'}
        Group(trip.nk).send(message)
        self.assertEqual(message, client.receive())
```

Add the import:

```python
from channels import Group
```

Ensure the test fails:

```bash
(env)$ python manage.py test example.tests
```

Error:

```bash
AssertionError: {'detail': 'This is a test message.'} != None
```

### Consumer

Django has a concept of sessions, which allows the app to store arbitrary user information on the server. That data is tied to a session ID, which the server passes to the client as a cookie. Whenever a user submits a request, the client will pass that session ID back to the server, and the session-related data can be accessed.

Channels has the same concept, except the session is associated with a WebSockets message instead of an HTTP request. This session data can be accessed through the `channel_session` variable, and our code will use this variable to store a list of trip NKs associated with the user. Since a client initiates a WebSockets handshake using an HTTP request, we can pluck the user information from that request and tack it onto our WebSockets messages by adding the class variable `http_user` to our consumer.

Update *example/consumers.py*:

```python
from channels import Group
from channels.generic.websockets import JsonWebsocketConsumer
from .models import Trip
from .serializers import TripSerializer


class TripConsumer(JsonWebsocketConsumer):
    http_user = True

    def user_trip_nks(self):
        raise NotImplementedError()

    def connect(self, message, **kwargs):
        self.message.reply_channel.send({'accept': True})
        if self.message.user.is_authenticated:
            # Get the trips associated with the user (as a driver or a rider).
            # Add the list of trip NKs to the user's channel session data.
            trip_nks = list(self.user_trip_nks())
            self.message.channel_session['trip_nks'] = trip_nks

            # Add the user's reply channel to each trip group.
            for trip_nk in trip_nks:
                Group(trip_nk).add(self.message.reply_channel)

    def disconnect(self, message, **kwargs):
        # Remove the user's reply channel from each associated trip group.
        if 'trip_nks' in message.channel_session:
            for trip_nk in message.channel_session['trip_nks']:
                Group(trip_nk).discard(message.reply_channel)


class DriverConsumer(TripConsumer):
    def user_trip_nks(self):
        return []


class RiderConsumer(TripConsumer):
    def user_trip_nks(self):
        # Find all active trips for the rider.
        return self.message.user.trips_as_rider.exclude(
            status=Trip.COMPLETED).only('nk').values_list('nk', flat=True)

    def receive(self, content, **kwargs):
        # Create a trip using the data passed in the request.
        serializer = TripSerializer(data=content)
        serializer.is_valid(raise_exception=True)
        trip = serializer.create(serializer.validated_data)

        # Add the new trip NK to the rider's channel session.
        self.message.channel_session['trip_nks'].append(trip.nk)

        # Add the user's reply channel to the new trip group.
        Group(trip.nk).add(self.message.reply_channel)

        # Send the serialized trip data to everyone in the trip group.
        trips_data = TripSerializer(trip).data
        self.group_send(name=trip.nk, content=trips_data)
```

We modified our `TripConsumer` class to manage the session data on the WebSockets messages. After establishing a connection with the client, the server retrieved a list of all of the trips that are relevant to the user. The trips' natural keys are extracted and added to the session data, and then the user's reply channel is added to a list of clients grouped by each trip NK. When the client disconnects, its reply channel is removed from the appropriate groups.

Lastly, we modified the `RiderConsumer` class so that we add the newly created trip NK to the user's session data and append the user's reply channel to the new group.

After completing the changes above, our tests should complete successfully:

```bash
(env)$ python manage.py test example.tests
```

## Drivers

Next, we need to add some functionality to handle driver actions. Whereas only riders can create trips, only drivers can update them.

### Test

Add the following tests to `WebSocketTripTest`:

```python
  def update_trip(self, driver, trip, status):
      client = self.connect_as_driver(driver)
      client.send_and_consume('websocket.receive', path='/driver/', content={
          'text': {
              'nk': trip.nk,
              'pick_up_address': trip.pick_up_address,
              'drop_off_address': trip.drop_off_address,
              'status': status,
              'driver': UserSerializer(driver).data
          }
      })
      return client

  def test_driver_can_update_trips(self):
      trip = Trip.objects.create(pick_up_address='A', drop_off_address='B')
      client = self.update_trip(self.driver, trip=trip, status=Trip.STARTED)
      trip = Trip.objects.get(nk=trip.nk)
      self.assertEqual(TripSerializer(trip).data, client.receive())

  def test_driver_is_subscribed_to_trip_channel_on_update(self):
      trip = Trip.objects.create(pick_up_address='A', drop_off_address='B')
      client = self.update_trip(self.driver, trip=trip, status=Trip.STARTED)
      client.receive()
      trip = Trip.objects.last()
      message = {'detail': 'This is a test message.'}
      Group(trip.nk).send(message)
      self.assertEqual(message, client.receive())
```

We created an `update_trip()` helper function to support repeated functionality. We also added two tests that mirror the previous rider tests: Drivers should be able to update trips and they should be subscribed to that trip's client group when they accept a trip through the update.

Failing tests, same story.

```bash
(env)$ python manage.py test example.tests
```

Errors:

```
AssertionError:
{'id': 1, 'rider': None, 'nk': '18728536a[192 chars]None} != None

...

AssertionError: {'detail': 'This is a test message.'} != None
```

### Serializer

Update the `TripSerializer`:

```python
class TripSerializer(serializers.ModelSerializer):
    rider = ReadOnlyUserSerializer(allow_null=True, required=False)
    driver = ReadOnlyUserSerializer(allow_null=True, required=False)

    def create(self, validated_data):
        data = validated_data.pop('rider', None)
        trip = super().create(validated_data)
        if data:
            trip.rider = \
                get_user_model().objects.get(username=data['username'])
        trip.save()
        return trip

    def update(self, instance, validated_data):
        data = validated_data.pop('driver', None)
        if data:
            instance.driver = \
                get_user_model().objects.get(username=data['username'])
        instance = super().update(instance, validated_data)
        return instance

    class Meta:
        model = Trip
        fields = '__all__'
        read_only_fields = ('id', 'nk', 'created', 'updated',)
```

We added the ability to update a trip. Notice that the driver is now added to the trip when it is updated.

### Consumer

To flesh out the `DriverConsumer` logic, when drivers connect, we want them placed in a group so that they all get the broadcasted rider requests.

```python
class DriverConsumer(TripConsumer):
    groups = ['drivers']

    def user_trip_nks(self):
        return self.message.user.trips_as_driver.exclude(
            status=Trip.COMPLETED).only('nk').values_list('nk', flat=True)

    def connect(self, message, **kwargs):
        super().connect(message, **kwargs)

        # Add all drivers to a special group.
        Group('drivers').add(self.message.reply_channel)

    def receive(self, content, **kwargs):
        # Find an existing trip by its NK.
        trip = Trip.objects.get(nk=content.get('nk'))

        # Update the trip using the request data.
        serializer = TripSerializer(data=content)
        serializer.is_valid(raise_exception=True)
        trip = serializer.update(trip, serializer.validated_data)

        # Add the trip NK to the driver's channel session.
        self.message.channel_session['trip_nks'].append(trip.nk)

        # Add the user's reply channel to the trip group.
        Group(trip.nk).add(self.message.reply_channel)

        # Send the serialized trip data to everyone in the trip group.
        trips_data = TripSerializer(trip).data
        self.group_send(name=trip.nk, content=trips_data)
```

So, when the `DriverConsumer` receives a message from the client, it parses the request data and updates the targeted trip. It then adds the trip data to a new group of clients identified by the trip NK.

```bash
(env)$ python manage.py test example.tests
```

## Alerts

Here's our final bit of functionality: We want to make sure that all drivers are alerted when a rider requests a new ride. We also want to make sure that the rider who requests the trip is alerted when a driver starts the trip.

### Test

Update *example/tests.py*:

```python
class WebSocketTripTest(ChannelTestCase):

    ...

    def test_driver_is_alerted_on_trip_creation(self):
        client = self.connect_as_driver(self.driver)
        self.create_trip(self.rider)
        trip = Trip.objects.last()
        self.assertEqual(TripSerializer(trip).data, client.receive())

    def test_rider_is_alerted_on_trip_update(self):
        client = self.create_trip(self.rider)
        client.receive()
        trip = Trip.objects.last()
        self.update_trip(self.driver, trip=trip, status=Trip.STARTED)
        trip = Trip.objects.get(nk=trip.nk)
        self.assertEqual(TripSerializer(trip).data, client.receive())
```

Error when running the tests:

```
AssertionError:
{'id': 1, 'rider': None, 'driver': None, [192 chars]TED'} != None
```

Why only one failure? The `DriverConsumer` is already equipped to alert the rider. We need to modify the `RiderConsumer` to broadcast the alert to all of the drivers.

### Consumer

*example/consumers.py*:

```python
class RiderConsumer(TripConsumer):
    def user_trip_nks(self):
        # Find all active trips for the rider.
        return self.message.user.trips_as_rider.exclude(
            status=Trip.COMPLETED).only('nk').values_list('nk', flat=True)

    def receive(self, content, **kwargs):
        # Create a trip using the data passed in the request.
        serializer = TripSerializer(data=content)
        serializer.is_valid(raise_exception=True)
        trip = serializer.create(serializer.validated_data)

        # Add the new trip NK to the rider's channel session.
        self.message.channel_session['trip_nks'].append(trip.nk)

        # Add the user's reply channel to the new trip group.
        Group(trip.nk).add(self.message.reply_channel)

        # Send the serialized trip data to everyone in the trip group.
        trips_data = TripSerializer(trip).data
        self.group_send(name=trip.nk, content=trips_data)

        # Send trip request to all drivers.
        self.group_send(name='drivers', content=trips_data)
```

One last test run.

```bash
(env)$ python manage.py test example.tests
```
