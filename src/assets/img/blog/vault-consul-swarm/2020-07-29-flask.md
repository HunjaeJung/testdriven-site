<!-- ---
title: Deploying Vault and Consul
layout: blog
share: true
toc: true
permalink: deploying-vault-and-consul
type: blog
author: Michael Herman
lastname: herman
description:
keywords: "vault, consul, hashicorp, secrets, docker, devops"
image: assets/img/blog/vault-consul-docker/managing_secrets_vault_consul.png
image_alt: vault and consul
blurb:
date: 2018-07-29
---
## Flask Example

https://devopsideas.com/using-hashicorp-vault-secrets-engines/


https://github.com/RyanHartje/containers/blob/master/consul-vault/docker-compose.yml

Let's look at a practical example with Flask.

Clone down the [vault-docker-example](https://github.com/testdrivenio/vault-docker-example) repo, and then check out the [v1](https://github.com/testdrivenio/vault-docker-example/releases/tag/v1) tag to the master branch:

```sh
$ git clone https://github.com/testdrivenio/vault-docker-example --branch v1 --single-branch
$ cd vault-docker-example
$ git checkout tags/v1 -b master
```

Take a quick look at the code:

```sh
├── Dockerfile
├── entrypoint.sh
├── manage.py
├── project
│   ├── __init__.py
│   ├── api
│   │   ├── __init__.py
│   │   ├── main.py
│   │   ├── models.py
│   │   └── users.py
│   └── config.py
└── requirements.txt
```

Essentially, we need to define three environment variables:

1. `DB_USER`
1. `DB_PASSWORD`
1. `DB_SERVER`

Code:

```python
import os

USER = os.environ.get('DB_USER')
PASSWORD = os.environ.get('DB_PASSWORD')
SERVER = os.environ.get('DB_SERVER')


class ProductionConfig():
    """Production configuration"""
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    SQLALCHEMY_DATABASE_URI = f'postgres://{USER}:{PASSWORD}@{SERVER}:5432/{USER}'
```

To test this out, set up a few Postgres database on [ElephantSQL](https://www.elephantsql.com/). Now, we can set the provided username, password, and server as secrets in Vault:

```sh
$ curl \
    -H "X-Vault-Token: $VAULT_TOKEN" \
    -H "Content-Type: application/json" \
    -X POST \
    -d '{"value":"pellefant.db.elephantsql.com"}' \
    http://127.0.0.1:8200/v1/secret/app/server

$ curl \
    -H "X-Vault-Token: $VAULT_TOKEN" \
    -H "Content-Type: application/json" \
    -X POST \
    -d '{"value":"oijnkhzi"}' \
    http://127.0.0.1:8200/v1/secret/app/user

$ curl \
    -H "X-Vault-Token: $VAULT_TOKEN" \
    -H "Content-Type: application/json" \
    -X POST \
    -d '{"value":"B02NMgb7Cq0N0gQRdFbmsfd9hArtSg7q"}' \
    http://127.0.0.1:8200/v1/secret/app/password
```

Create a new file called *run.sh* in the project root:

```sh
#!/bin/sh

rm -f .env

server=$(curl  -H "X-Vault-Token: $VAULT_TOKEN" -X GET http://127.0.0.1:8200/v1/secret/app/server)
echo DB_SERVE=$(echo $server | jq -r .data.value) >> .env

user=$(curl  -H "X-Vault-Token: $VAULT_TOKEN" -X GET http://127.0.0.1:8200/v1/secret/app/user)
echo DB_USER=$(echo $user | jq -r .data.value) >> .env

password=$(curl  -H "X-Vault-Token: $VAULT_TOKEN" -X GET http://127.0.0.1:8200/v1/secret/app/password)
echo DB_PASSWORD=$(echo $password | jq -r .data.value) >> .env

docker-compose up -d --build
```

Update the environment variable. Build the images and spin up the containers:

```sh
$ sh run.sh
```

Verify that the environment variables were added successfully:

```sh
$ docker-compose exec web env
```

Create and seed the database `users` table:

```db
$ docker-compose run web python manage.py recreate_db
$ docker-compose run web python manage.py seed_db
```

Test it out in the browser at [http://localhost:5000/users](http://localhost:5000/users):

```json
{
  "status": "success",
  "users": [{
    "active": true,
    "admin": false,
    "email": "michael@notreal.com",
    "id": 1,
    "username": "michael"
  }]
}
```

Bring down the containers before moving on:

```sh
$ docker-compose down
```

## S3 Backend

To take advantage of Vault's high availability, let's set up an external backend on [S3](https://www.vaultproject.io/docs/configuration/storage/s3.html). Assuming you have an account set up with [AWS](https://aws.amazon.com/), navigate to the [S3 console](https://console.aws.amazon.com/s3/) and create a new bucket.

> High availability backends - consul

Update *vault-config.json*:

```json
{
  "backend": {
    "s3": {
      "access_key": "AKIAJ7WMTEKSSZ4NTDCA",
      "secret_key": "l9Bh+Ag5K7Immvau1/bNTpiB49XtPxvymogRk8bs",
      "bucket": "vault-example",
      "region": "us-east-1"
    }
  },
  "listener":{
    "tcp":{
      "address": "0.0.0.0:8200",
      "tls_disable": 1
    }
  }
}
```

> Be sure to update the `bucket` name and the `region`.

Spin the container back up:

```sh
$ docker-compose up -d --build
```

Enter the bash shell within the container, then init and unseal Vault. Take note of the tokens again. Then, add the `app` policy and create a new token:

```sh
# vault login 727025ef-f7ce-3978-7e76-7ea46aa48f28
# vault policy write app /vault/policies/app-policy.json
# vault token create -policy=app
```

Exit the shell. Update the root token environment variable locally. Add the secrets:

```sh
$ curl \
    -H "X-Vault-Token: $VAULT_TOKEN" \
    -H "Content-Type: application/json" \
    -X POST \
    -d '{"value":"pellefant.db.elephantsql.com"}' \
    http://127.0.0.1:8200/v1/secret/app/server

$ curl \
    -H "X-Vault-Token: $VAULT_TOKEN" \
    -H "Content-Type: application/json" \
    -X POST \
    -d '{"value":"oijnkhzi"}' \
    http://127.0.0.1:8200/v1/secret/app/user

$ curl \
    -H "X-Vault-Token: $VAULT_TOKEN" \
    -H "Content-Type: application/json" \
    -X POST \
    -d '{"value":"B02NMgb7Cq0N0gQRdFbmsfd9hArtSg7q"}' \
    http://127.0.0.1:8200/v1/secret/app/password
```

Update the environment variable. Build the images and spin up the containers:

```sh
$ sh run.sh
```

Create and seed the database `users` table:

```db
$ docker-compose run web python manage.py recreate_db
$ docker-compose run web python manage.py seed_db
```

Be sure to bring down the containers once done.

> You can now add Vault replicas and point them to the same S3 backend. You can certainly spin up more Vault instances on the same machine using Docker Compose, but you'd really want to add new replicas on new machines. The easiest way to do this is with Docker Swarm. Contact me if you'd like to see a tutorial on scaling Vault using Docker Swarm.

## Deploying to EC2

Moving right along, let's spin up Vault on an EC2 instance. Create a new Docker Machine using the [amazonec2 driver](https://docs.docker.com/machine/drivers/aws/):

```sh
$ docker-machine create --driver amazonec2 vault
```

> You must have an AWS credential file set up for this command to work. Review the [docs](https://docs.docker.com/machine/drivers/aws/) for more info on setting this up.

Before you deploy, remove the volumes from the *docker-compose.yml* file:

```yaml
version: '3.6'

services:

  vault:
    build:
      context: ./vault
      dockerfile: Dockerfile
    container_name: vault
    hostname: vault
    ports:
      - 8200:8200
    environment:
      - VAULT_ADDR=http://127.0.0.1:8200
    command: server -config=/vault/config/vault-config.json
    cap_add:
      - IPC_LOCK

  web:
    build:
      context: ./web
      dockerfile: Dockerfile
    ports:
      - 5000:5000
    environment:
      - FLASK_ENV=production
      - APP_SETTINGS=project.config.ProductionConfig
    env_file:
      - .env
```

Update the *Dockerfile* as well, to add the config and policy files to the image:

```yaml
# base image
FROM alpine:3.7

# set vault version
ENV VAULT_VERSION 0.10.3

# create a new directory
RUN mkdir /vault

# download dependencies
RUN apk --no-cache add \
      bash \
      ca-certificates \
      wget

# download and set up vault
RUN wget --quiet --output-document=/tmp/vault.zip https://releases.hashicorp.com/vault/${VAULT_VERSION}/vault_${VAULT_VERSION}_linux_amd64.zip && \
    unzip /tmp/vault.zip -d /vault && \
    rm -f /tmp/vault.zip && \
    chmod +x vault

# add the config and policy files
COPY ./config/vault-config.json /vault/config/vault-config.json
COPY ./policies/app-policy.json /vault/policies/app-policy.json

# expose port 8200
EXPOSE 8200

# run vault
ENTRYPOINT ["vault"]
```

Point the Docker daemon at the new machine and deploy Vault:

```sh
$ docker-machine env vault
$ eval $(docker-machine env vault)
$ docker-compose up -d --build
```

You will probably need to add ports 8200 and 5000 to the [Security Group](https://stackoverflow.com/questions/26338301/ec2-how-to-add-port-8080-in-security-group):

TODO: update image

<img src="/assets/img/blog/vault-and-consul/aws-security-groups.png" style="max-width:90%;" alt="aws security groups">

Update *run.sh* to take in a URL as a command-lin argument:

```sh
#!/bin/sh

URL=$1

rm -f .env

server=$(curl  -H "X-Vault-Token: $VAULT_TOKEN" -X GET http://${URL}:8200/v1/secret/app/server)
echo DB_SERVER=$(echo $server | jq -r .data.value) >> .env

user=$(curl  -H "X-Vault-Token: $VAULT_TOKEN" -X GET http://${URL}:8200/v1/secret/app/user)
echo DB_USER=$(echo $user | jq -r .data.value) >> .env

password=$(curl  -H "X-Vault-Token: $VAULT_TOKEN" -X GET http://${URL}:8200/v1/secret/app/password)
echo DB_PASSWORD=$(echo $password | jq -r .data.value) >> .env

docker-compose up -d --build
```

Grab the public IP for the EC2 instance and then update the containers:

```sh
$ docker-machine ip vault
54.145.218.135

$ sh run.sh 54.145.218.135
```

As long as you don't remove the files and folders in the S3 bucket, you won't need to init the Vault. You will need to unseal it, though:

```sh
$ docker-compose exec vault bash

# vault operator unseal
# exit
```

Verify that the environment variables were added successfully:

```sh
$ docker-compose exec web env
```

Create and seed the database `users` table:

```db
$ docker-compose run web python manage.py recreate_db
$ docker-compose run web python manage.py seed_db
```

Test it out in the browser at [http://54.145.218.135:5000/users](http://54.145.218.135:5000/users).

### next time

and Consul within Docker containers . Finally, we'll look at a real-world example of using Vault (on EC2 with an S3 backend) as a secret store for a Flask web app backed by Postgres.

https://github.com/norhe/vault-approle-python-example/blob/master/README.md
https://theithollow.com/2018/06/04/use-hashicorps-vault-to-dynamically-create-mysql-credentials/
https://github.com/nathandines/docker-vault-samplewebapp
https://github.com/sethvargo/vault-demo
https://tech.gogoair.com/super-secret-dynamic-secrets-with-vault-cf6f29fefc8f
https://www.amon.cx/blog/managing-all-secrets-with-vault/

What's next?

Enabling TLS - nginx?

1. We’re going to define a non-production ready environment for our tests. If you want to learn what you should do to productionise this environment, please follow their hardening guide. https://www.vaultproject.io/guides/operations/production.html -->
